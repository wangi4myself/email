# 文档驱动开发模式 (Documentation-Driven Development)

> 先写文档，再写代码的开发范式

## 核心概念

**文档驱动开发 (DDD - Doc-Driven Development)** 是一种开发方法论：

```
传统模式: 代码 → 文档 → 测试
文档驱动: 规格说明 → 测试 → 代码 → 自动生成文档
```

核心思想：**规格说明（Specification）是"单一事实来源"（Single Source of Truth）**

---

## 主要形式

### 1. API 规格驱动 (OpenAPI/Swagger)

```yaml
# openapi.yaml - 先定义 API 规格
openapi: 3.0.0
paths:
  /subscriptions:
    post:
      summary: 创建订阅
      requestBody:
        content:
          application/x-www-form-urlencoded:
            schema:
              type: object
              properties:
                email:
                  type: string
                  format: email
                name:
                  type: string
              required: [email, name]
      responses:
        '200':
          description: 订阅成功
```

**工作流程**:
1. 编写 OpenAPI 规格文件
2. 自动生成：客户端 SDK、服务端桩代码、文档、Mock 服务器
3. 实现业务逻辑
4. 规格即文档，永远同步

**工具链**:

| 工具 | 功能 |
|------|------|
| OpenAPI Generator | 生成客户端/服务端代码 |
| Swagger UI | 交互式 API 文档 |
| Prism | Mock 服务器 |
| Dredd | API 契约测试 |

---

### 2. Spec-Kit 模式

**Spec-Kit** 是一种将规格说明与测试紧密结合的开发模式。核心特点：

```
规格文档 (Markdown/YAML)
    ↓
解析器提取测试用例
    ↓
自动生成测试代码
    ↓
运行测试验证实现
```

**典型实现**:

```markdown
# 用户订阅功能规格

## 场景：成功订阅

**Given** 用户提供有效的邮箱和姓名
**When** 发送 POST 请求到 /subscriptions
**Then** 返回 200 状态码
**And** 数据库中创建一条 pending_confirmation 状态的记录
```

这种 Gherkin 语法可以被 Cucumber 等工具解析执行。

---

### 3. 类型驱动开发 (Type-Driven Development)

在 Rust/TypeScript 中特别流行：

```rust
// 先定义类型作为"规格"
pub struct SubscriberEmail(String);
pub struct SubscriberName(String);

pub struct NewSubscriber {
    pub email: SubscriberEmail,
    pub name: SubscriberName,
}

// 类型本身就是文档和约束
impl SubscriberEmail {
    pub fn parse(s: String) -> Result<Self, String> {
        // 验证逻辑
    }
}
```

**Rust 的优势**: 类型系统强大，编译器就是"规格检查器"

---

### 4. README 驱动开发 (RDD)

Tom Preston-Werner（GitHub 创始人）提出：

> "先写 README，再写代码"

```markdown
# My CLI Tool

## Installation
cargo install my-cli

## Usage
my-cli --input file.txt --output result.json

## Examples
# 基本用法
my-cli process data.csv

# 带选项
my-cli process data.csv --format json --verbose
```

**优势**:
- 强迫你从用户角度思考
- 避免过度设计
- README 就是产品规格

---

## 对比传统开发

| 方面 | 传统模式 | 文档驱动 |
|------|----------|----------|
| 文档时机 | 事后补充 | 开发前 |
| 文档质量 | 容易过时 | 始终同步 |
| API 设计 | 边写边改 | 预先设计 |
| 团队协作 | 等实现完成 | 前后端并行开发 |
| 测试来源 | 人工编写 | 从规格生成 |

---

## 实用工具生态

### API 规格工具

| 工具 | 语言/生态 | 特点 |
|------|-----------|------|
| OpenAPI/Swagger | 通用 | 行业标准 |
| GraphQL Schema | GraphQL | 强类型 |
| Protocol Buffers | gRPC | 高性能 |
| JSON Schema | 通用 | 数据验证 |

### 行为规格工具 (BDD)

| 工具 | 语言 | 说明 |
|------|------|------|
| Cucumber | 多语言 | Gherkin 语法 |
| behave | Python | Python BDD |
| RSpec | Ruby | Ruby 测试框架 |
| Jest + Gherkin | JS/TS | Node.js 生态 |

### Rust 生态

| 工具 | 用途 |
|------|------|
| `utoipa` | 从 Rust 代码生成 OpenAPI |
| `paperclip` | OpenAPI 代码生成 |
| `schemars` | JSON Schema 生成 |

---

## 在当前项目中的应用

你的邮件订阅项目可以这样应用：

### 1. 定义 API 规格

```yaml
# api-spec.yaml
paths:
  /subscriptions:
    post:
      requestBody:
        required: true
        content:
          application/x-www-form-urlencoded:
            schema:
              $ref: '#/components/schemas/SubscriptionRequest'
      responses:
        '200':
          description: Subscription created
        '400':
          description: Invalid input

components:
  schemas:
    SubscriptionRequest:
      type: object
      required: [email, name]
      properties:
        email:
          type: string
          format: email
        name:
          type: string
          minLength: 1
```

### 2. 类型作为规格 (当前已实现)

```rust
// src/domain/subscriber_email.rs
// 类型定义本身就是规格文档
pub struct SubscriberEmail(String);

impl SubscriberEmail {
    pub fn parse(s: String) -> Result<Self, String> {
        // 规格：必须是有效邮箱格式
    }
}
```

### 3. 测试作为可执行规格

```rust
// tests/api/subscriptions.rs
// 测试用例就是行为规格
#[tokio::test]
async fn subscribe_returns_200_for_valid_form_data() {
    // Given: 有效的表单数据
    // When: POST /subscriptions
    // Then: 返回 200，数据库有记录
}
```

---

## 推荐实践

1. **小项目**: README 驱动 + 类型驱动
2. **API 项目**: OpenAPI 规格优先
3. **团队项目**: 完整的规格文档 + 契约测试
4. **Rust 项目**: 充分利用类型系统作为"活文档"

---

## 总结

文档驱动开发的核心价值：

- **设计先行**: 避免边写边改的混乱
- **文档即代码**: 规格可以生成代码/测试
- **团队对齐**: 前后端基于同一规格并行开发
- **可验证性**: 规格可以自动化测试

对于 Node.js 开发者转 Rust：Rust 的类型系统天然支持"类型即规格"的开发模式，编译器帮你验证规格的一致性。
